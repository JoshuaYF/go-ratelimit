package ratelimit

import (
	"errors"
	"time"
)

type LeakyBucketRateLimiter[Req any, Res any] struct {
	capacity int64                // The capacity of the bucket.
	rate     int64                // The leakage rate of the leaky bucket per second.
	bucket   chan *Task[Req, Res] // Task Leaky Bucket.
	t        *time.Ticker         // The ticker generated by the rate variable.
}

func NewLeakyBucketRateLimiter[Req any, Res any](capacity, rate int64) *LeakyBucketRateLimiter[Req, Res] {
	limiter := &LeakyBucketRateLimiter[Req, Res]{
		capacity: capacity,
		rate:     rate,
		bucket:   make(chan *Task[Req, Res], capacity),
		t:        time.NewTicker(time.Duration(time.Second.Nanoseconds() / rate)),
	}

	go func() {
		for {
			select {
			case <-limiter.t.C:
				limiter.consume()
			}
		}
	}()

	return limiter
}

func (limiter *LeakyBucketRateLimiter[Req, Res]) ResetRate(rate int64) {
	limiter.rate = rate
	limiter.t.Reset(time.Duration(time.Second.Nanoseconds() / rate))
}

// TryRequest Put the task into the leaky bucket. If it's full, discard it and return an error.
func (limiter *LeakyBucketRateLimiter[Req, Res]) TryRequest(task *Task[Req, Res]) (err error) {
	task.ResChan = make(chan Res)
	task.PanicChan = make(chan any, 1)

	select {
	case limiter.bucket <- task:

		return nil
	default:

		return errors.New("rejected")
	}
}

// Request Put the task into the leaky bucket. if it's full, block.
func (limiter *LeakyBucketRateLimiter[Req, Res]) Request(task *Task[Req, Res]) {
	select {
	case limiter.bucket <- task:
		task.ResChan = make(chan Res)
		task.PanicChan = make(chan any, 1)
	}
}

func (limiter *LeakyBucketRateLimiter[Req, Res]) consume() {
	select {
	case task := <-limiter.bucket:
		// got task
		task.asyncExec()
	default:
		// no task
	}
}
