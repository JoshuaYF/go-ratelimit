package main

import (
	"errors"
	"time"
)

type LeakyBucketRateLimiter[Req any, Res any] struct {
	capacity int64                // The capacity of the bucket.
	rate     int64                // The leakage rate of the leaky bucket per second.
	bucket   chan *Task[Req, Res] // Task Leaky Bucket.
	t        *time.Ticker         // The ticker generated by the rate variable.
}

type Invoker[Req any, Res any] func(Req) Res

type Task[Req any, Res any] struct {
	Invoker   Invoker[Req, Res]
	Request   Req
	ResChan   chan Res
	PanicChan chan any
}

func (t *Task[Req, Res]) GetResult() (result Res, _panic any) {
	select {
	case result = <-t.ResChan:
	case _panic = <-t.PanicChan:
	}

	return
}

func NewLeakyBucketRateLimiter[Req any, Res any](capacity, rate int64) *LeakyBucketRateLimiter[Req, Res] {
	limiter := &LeakyBucketRateLimiter[Req, Res]{
		capacity: capacity,
		rate:     rate,
		bucket:   make(chan *Task[Req, Res], capacity),
		t:        time.NewTicker(time.Duration(time.Second.Nanoseconds() / rate)),
	}

	go func() {
		for {
			select {
			case <-limiter.t.C:
				limiter.consume()
			}
		}
	}()

	return limiter
}

func (limiter *LeakyBucketRateLimiter[Req, Res]) ResetRate(rate int64) {
	limiter.rate = rate
	limiter.t.Reset(time.Duration(time.Second.Nanoseconds() / rate))
}

// TryRequest Put the task into the leaky bucket. If it's full, discard it and return an error.
func (limiter *LeakyBucketRateLimiter[Req, Res]) TryRequest(task *Task[Req, Res]) (err error) {
	task.ResChan = make(chan Res)
	task.PanicChan = make(chan any, 1)

	select {
	case limiter.bucket <- task:

		return nil
	default:

		return errors.New("rejected")
	}
}

// Request Put the task into the leaky bucket. if it's full, block.
func (limiter *LeakyBucketRateLimiter[Req, Res]) Request(task *Task[Req, Res]) {
	select {
	case limiter.bucket <- task:
		task.ResChan = make(chan Res)
		task.PanicChan = make(chan any, 1)
	}
}

func (limiter *LeakyBucketRateLimiter[Req, Res]) consume() {
	select {
	case task := <-limiter.bucket:
		// got task
		go func() {
			defer func() {
				r := recover()
				if r != nil {
					task.PanicChan <- r
				}
			}()
			res := task.Invoker(task.Request)
			select {
			case task.ResChan <- res:
				// put into ResChan success
			default:
				// no listener
			}
		}()
	default:
		// no task
	}
}
